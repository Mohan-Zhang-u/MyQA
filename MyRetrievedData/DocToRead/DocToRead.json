{"data": [{"title": "", "paragraphs": [{"context": "Deep learning\nFrom Wikipedia, the free encyclopedia\nJump to navigationJump to search\nFor deep versus shallow learning in educational psychology, see Student approaches to learning. For more information, see Artificial neural network.\nMachine learning and\ndata mining\nKernel Machine.svg\nProblems[show]\nSupervised learning\n(classification \u2022 regression)\n[show]\nClustering[show]\nDimensionality reduction[show]\nStructured prediction[show]\nAnomaly detection[show]\nArtificial neural networks[show]\nReinforcement learning[show]\nTheory[show]\nMachine-learning venues[show]\nGlossary of artificial intelligence[show]\nRelated articles[show]\nPortal-puzzle.svg Machine learning portal\nvte\nDeep learning (also known as deep structured learning or hierarchical learning) is part of a broader family of machine learning methods based on learning data representations, as opposed to task-specific algorithms. Learning can be supervised, semi-supervised or unsupervised.[1][2][3]\n\nDeep learning architectures such as deep neural networks, deep belief networks and recurrent neural networks have been applied to fields including computer vision, speech recognition, natural language processing, audio recognition, social network filtering, machine translation, bioinformatics, drug design, medical image analysis, material inspection and board game programs, where they have produced results comparable to and in some cases superior to human experts.[4][5][6]\n\nDeep learning models are vaguely inspired by information processing and communication patterns in biological nervous systems yet have various differences from the structural and functional properties of biological brains (especially human brains), which make them incompatible with neuroscience evidences.[7][8][9]\n\n\nContents\n1\tDefinition\n2\tOverview\n3\tInterpretations\n4\tHistory\n4.1\tDeep learning revolution\n5\tNeural networks\n5.1\tArtificial neural networks\n5.2\tDeep neural networks\n6\tApplications\n6.1\tAutomatic speech recognition\n6.2\tImage recognition\n6.3\tVisual art processing\n6.4\tNatural language processing\n6.5\tDrug discovery and toxicology\n6.6\tCustomer relationship management\n6.7\tRecommendation systems\n6.8\tBioinformatics\n6.9\tMobile advertising\n6.10\tImage restoration\n6.11\tFinancial fraud detection\n6.12\tMilitary\n7\tRelation to human cognitive and brain development\n8\tCommercial activity\n9\tCriticism and comment\n9.1\tTheory\n9.2\tErrors\n9.3\tCyberthreat\n10\tSee also\n11\tReferences\n12\tExternal links\nDefinition\nDeep learning is a class of machine learning algorithms that:[10](pp199\u2013200)\n\nuse a cascade of multiple layers of nonlinear processing units for feature extraction and transformation. Each successive layer uses the output from the previous layer as input.\nlearn in supervised (e.g., classification) and/or unsupervised (e.g., pattern analysis) manners.\nlearn multiple levels of representations that correspond to different levels of abstraction; the levels form a hierarchy of concepts.\nOverview\nMost modern deep learning models are based on an artificial neural network, although they can also include propositional formulas or latent variables organized layer-wise in deep generative models such as the nodes in deep belief networks and deep Boltzmann machines.[11]\n\nIn deep learning, each level learns to transform its input data into a slightly more abstract and composite representation. In an image recognition application, the raw input may be a matrix of pixels; the first representational layer may abstract the pixels and encode edges; the second layer may compose and encode arrangements of edges; the third layer may encode a nose and eyes; and the fourth layer may recognize that the image contains a face. Importantly, a deep learning process can learn which features to optimally place in which level on its own. (Of course, this does not completely obviate the need for hand-tuning; for example, varying numbers of layers and layer sizes can provide different degrees of abstraction.)[1][12]\n\nThe \\\"deep\\\" in \\\"deep learning\\\" refers to the number of layers through which the data is transformed. More precisely, deep learning systems have a substantial credit assignment path (CAP) depth. The CAP is the chain of transformations from input to output. CAPs describe potentially causal connections between input and output. For a feedforward neural network, the depth of the CAPs is that of the network and is the number of hidden layers plus one (as the output layer is also parameterized). For recurrent neural networks, in which a signal may propagate through a layer more than once, the CAP depth is potentially unlimited.[2] No universally agreed upon threshold of depth divides shallow learning from deep learning, but most researchers agree that deep learning involves CAP depth > 2. CAP of depth 2 has been shown to be a universal approximator in the sense that it can emulate any function.[citation needed] Beyond that more layers do not add to the function approximator ability of the network. Deep models (CAP > 2) are able to extract better features than shallow models and hence, extra layers help in learning features.\n\nDeep learning architectures are often constructed with a greedy layer-by-layer method.[clarification needed][further explanation needed][citation needed] Deep learning helps to disentangle these abstractions and pick out which features improve performance.[1]\n\nFor supervised learning tasks, deep learning methods obviate feature engineering, by translating the data into compact intermediate representations akin to principal components, and derive layered structures that remove redundancy in representation.\n\nDeep learning algorithms can be applied to unsupervised learning tasks. This is an important benefit because unlabeled data are more abundant than labeled data. Examples of deep structures that can be trained in an unsupervised manner are neural history compressors[13] and deep belief networks.[1][14]\n\nInterpretations\nDeep neural networks are generally interpreted in terms of the universal approximation theorem[15][16][17][18][19] or probabilistic inference.[10][11][1][2][14][20][21]\n\nThe universal approximation theorem concerns the capacity of feedforward neural networks with a single hidden layer of finite size to approximate continuous functions.[15][16][17][18][19] In 1989, the first proof was published by George Cybenko for sigmoid activation functions[16] and was generalised to feed-forward multi-layer architectures in 1991 by Kurt Hornik.[17]\n\nThe probabilistic interpretation[20] derives from the field of machine learning. It features inference,[10][11][1][2][14][20] as well as the optimization concepts of training and testing, related to fitting and generalization, respectively. More specifically, the probabilistic interpretation considers the activation nonlinearity as a cumulative distribution function.[20] The probabilistic interpretation led to the introduction of dropout as regularizer in neural networks.[22] The probabilistic interpretation was introduced by researchers including Hopfield, Widrow and Narendra and popularized in surveys such as the one by Bishop.[23]\n\nHistory\nThe term Deep Learning was introduced to the machine learning community by Rina Dechter in 1986,[24][13] and to artificial neural networks by Igor Aizenberg and colleagues in 2000, in the context of Boolean threshold neurons.[25][26]\n\nThe first general, working learning algorithm for supervised, deep, feedforward, multilayer perceptrons was published by Alexey Ivakhnenko and Lapa in 1965.[27] A 1971 paper described a deep network with 8 layers trained by the group method of data handling algorithm.[28]\n\nOther deep learning working architectures, specifically those built for computer vision, began with the Neocognitron introduced by Kunihiko Fukushima in 1980.[29] In 1989, Yann LeCun et al. applied the standard backpropagation algorithm, which had been around as the reverse mode of automatic differentiation since 1970,[30][31][32][33] to a deep neural network with the purpose of recognizing handwritten ZIP codes on mail. While the algorithm worked, training required 3 days.[34]\n\nBy 1991 such systems were used for recognizing isolated 2-D hand-written digits, while recognizing 3-D objects was done by matching 2-D images with a handcrafted 3-D object model. Weng et al. suggested that a human brain does not use a monolithic 3-D object model and in 1992 they published Cresceptron,[35][36][37] a method for performing 3-D object recognition in cluttered scenes. Because it directly used natural images, Cresceptron started the beginning of general-purpose visual learning for natural 3D worlds. Cresceptron is a cascade of layers similar to Neocognitron. But while Neocognitron required a human programmer to hand-merge features, Cresceptron learned an open number of features in each layer without supervision, where each feature is represented by a convolution kernel. Cresceptron segmented each learned object from a cluttered scene through back-analysis through the network. Max pooling, now often adopted by deep neural networks (e.g. ImageNet tests), was first used in Cresceptron to reduce the position resolution by a factor of (2x2) to 1 through the cascade for better generalization.\n\nIn 1994, Andr\u00e9 de Carvalho, together with Mike Fairhurst and David Bisset, published experimental results of a multi-layer boolean neural network, also known as a weightless neural network, composed of a 3-layers self-organising feature extraction neural network module (SOFT) followed by a multi-layer classification neural network module (GSN), which were independently trained. Each layer in the feature extraction module extracted features with growing complexity regarding the previous layer.[38]\n\nIn 1995, Brendan Frey demonstrated that it was possible to train (over two days) a network containing six fully connected layers and several hundred hidden units using the wake-sleep algorithm, co-developed with Peter Dayan and Hinton.[39] Many factors contribute to the slow speed, including the vanishing gradient problem analyzed in 1991 by Sepp Hochreiter.[40][41]\n\nSimpler models that use task-specific handcrafted features such as Gabor filters and support vector machines (SVMs) were a popular choice in the 1990s and 2000s, because of ANNs\\' computational cost and a lack of understanding of how the brain wires its biological networks.\n\nBoth shallow and deep learning (e.g., recurrent nets) of ANNs have been explored for many years.[42][43][44] These methods never outperformed non-uniform internal-handcrafting Gaussian mixture model/Hidden Markov model (GMM-HMM) technology based on generative models of speech trained discriminatively.[45] Key difficulties have been analyzed, including gradient diminishing[40] and weak temporal correlation structure in neural predictive models.[46][47] Additional difficulties were the lack of training data and limited computing power.\n\nMost speech recognition researchers moved away from neural nets to pursue generative modeling. An exception was at SRI International in the late 1990s. Funded by the US government\\'s NSA and DARPA, SRI studied deep neural networks in speech and speaker recognition. Heck\\'s speaker recognition team achieved the first significant success with deep neural networks in speech processing in the 1998 National Institute of Standards and Technology Speaker Recognition evaluation.[48] While SRI experienced success with deep neural networks in speaker recognition, they were unsuccessful in demonstrating similar success in speech recognition. The principle of elevating \\\"raw\\\" features over hand-crafted optimization was first explored successfully in the architecture of deep autoencoder on the \\\"raw\\\" spectrogram or linear filter-bank features in the late 1990s,[48] showing its superiority over the Mel-Cepstral features that contain stages of fixed transformation from spectrograms. The raw features of speech, waveforms, later produced excellent larger-scale results.[49]\n\nMany aspects of speech recognition were taken over by a deep learning method called long short-term memory (LSTM), a recurrent neural network published by Hochreiter and Schmidhuber in 1997.[50] LSTM RNNs avoid the vanishing gradient problem and can learn \\\"Very Deep Learning\\\" tasks[2] that require memories of events that happened thousands of discrete time steps before, which is important for speech. In 2003, LSTM started to become competitive with traditional speech recognizers on certain tasks.[51] Later it was combined with connectionist temporal classification (CTC)[52] in stacks of LSTM RNNs.[53] In 2015, Google\\'s speech recognition reportedly experienced a dramatic performance jump of 49% through CTC-trained LSTM, which they made available through Google Voice Search.[54]\n\nIn 2006, publications by Geoff Hinton, Ruslan Salakhutdinov, Osindero and Teh[55] [56][57] showed how a many-layered feedforward neural network could be effectively pre-trained one layer at a time, treating each layer in turn as an unsupervised restricted Boltzmann machine, then fine-tuning it using supervised backpropagation.[58] The papers referred to learning for deep belief nets.\n\nDeep learning is part of state-of-the-art systems in various disciplines, particularly computer vision and automatic speech recognition (ASR). Results on commonly used evaluation sets such as TIMIT (ASR) and MNIST (image classification), as well as a range of large-vocabulary speech recognition tasks have steadily improved.[59][60][61] Convolutional neural networks (CNNs) were superseded for ASR by CTC[52] for LSTM.[50][54][62][63][64][65][66] but are more successful in computer vision.\n\nThe impact of deep learning in industry began in the early 2000s, when CNNs already processed an estimated 10% to 20% of all the checks written in the US, according to Yann LeCun.[67] Industrial applications of deep learning to large-scale speech recognition started around 2010.\n\nThe 2009 NIPS Workshop on Deep Learning for Speech Recognition[68] was motivated by the limitations of deep generative models of speech, and the possibility that given more capable hardware and large-scale data sets that deep neural nets (DNN) might become practical. It was believed that pre-training DNNs using generative models of deep belief nets (DBN) would overcome the main difficulties of neural nets.[69] However, it was discovered that replacing pre-training with large amounts of training data for straightforward backpropagation when using DNNs with large, context-dependent output layers produced error rates dramatically lower than then-state-of-the-art Gaussian mixture model (GMM)/Hidden Markov Model (HMM) and also than more-advanced generative model-based systems.[59][70] The nature of the recognition errors produced by the two types of systems was characteristically different,[71][68] offering technical insights into how to integrate deep learning into the existing highly efficient, run-time speech decoding system deployed by all major speech recognition systems.[10][72][73] Analysis around 2009-2010, contrasted the GMM (and other generative speech models) vs. DNN models, stimulated early industrial investment in deep learning for speech recognition,[71][68] eventually leading to pervasive and dominant use in that industry. That analysis was done with comparable performance (less than 1.5% in error rate) between discriminative DNNs and generative models.[59][71][69][74]\n\nIn 2010, researchers extended deep learning from TIMIT to large vocabulary speech recognition, by adopting large output layers of the DNN based on context-dependent HMM states constructed by decision trees.[75][76][77][72]\n\nAdvances in hardware enabled the renewed interest. In 2009, Nvidia was involved in what was called the \u201cbig bang\u201d of deep learning, \u201cas deep-learning neural networks were trained with Nvidia graphics processing units (GPUs).\u201d[78] That year, Google Brain used Nvidia GPUs to create capable DNNs. While there, Ng determined that GPUs could increase the speed of deep-learning systems by about 100 times.[79] In particular, GPUs are well-suited for the matrix/vector math involved in machine learning.[80][81] GPUs speed up training algorithms by orders of magnitude, reducing running times from weeks to days.[82][83] Specialized hardware and algorithm optimizations can be used for efficient processing.[84]\n\nDeep learning revolution\nIn 2012, a team led by Dahl won the \\\"Merck Molecular Activity Challenge\\\" using multi-task deep neural networks to predict the biomolecular target of one drug.[85][86] In 2014, Hochreiter\\'s group used deep learning to detect off-target and toxic effects of environmental chemicals in nutrients, household products and drugs and won the \\\"Tox21 Data Challenge\\\" of NIH, FDA and NCATS.[87][88][89]\n\nSignificant additional impacts in image or object recognition were felt from 2011 to 2012. Although CNNs trained by backpropagation had been around for decades, and GPU implementations of NNs for years, including CNNs, fast implementations of CNNs with max-pooling on GPUs in the style of Ciresan and colleagues were needed to progress on computer vision.[80][81][34][90][2] In 2011, this approach achieved for the first time superhuman performance in a visual pattern recognition contest. Also in 2011, it won the ICDAR Chinese handwriting contest, and in May 2012, it won the ISBI image segmentation contest.[91] Until 2011, CNNs did not play a major role at computer vision conferences, but in June 2012, a paper by Ciresan et al. at the leading conference CVPR[4] showed how max-pooling CNNs on GPU can dramatically improve many vision benchmark records. In October 2012, a similar system by Krizhevsky et al.[5] won the large-scale ImageNet competition by a significant margin over shallow machine learning methods. In November 2012, Ciresan et al.\\'s system also won the ICPR contest on analysis of large medical images for cancer detection, and in the following year also the MICCAI Grand Challenge on the same topic.[92] In 2013 and 2014, the error rate on the ImageNet task using deep learning was further reduced, following a similar trend in large-scale speech recognition. The Wolfram Image Identification project publicized these improvements.[93]\n\nImage classification was then extended to the more challenging task of generating descriptions (captions) for images, often as a combination of CNNs and LSTMs.[94][95][96][97]\n\nSome researchers assess that the October 2012 ImageNet victory anchored the start of a \\\"deep learning revolution\\\" that has transformed the AI industry.[98]\n\nNeural networks\nArtificial neural networks\nMain article: Artificial neural network\nArtificial neural networks (ANNs) or connectionist systems are computing systems inspired by the biological neural networks that constitute animal brains. Such systems learn (progressively improve their ability) to do tasks by considering examples, generally without task-specific programming. For example, in image recognition, they might learn to identify images that contain cats by analyzing example images that have been manually labeled as \\\"cat\\\" or \\\"no cat\\\" and using the analytic results to identify cats in other images. They have found most use in applications difficult to express with a traditional computer algorithm using rule-based programming.\n\nAn ANN is based on a collection of connected units called artificial neurons, (analogous to biological neurons in a biological brain). Each connection (synapse) between neurons can transmit a signal to another neuron. The receiving (postsynaptic) neuron can process the signal(s) and then signal downstream neurons connected to it. Neurons may have state, generally represented by real numbers, typically between 0 and 1. Neurons and synapses may also have a weight that varies as learning proceeds, which can increase or decrease the strength of the signal that it sends downstream.\n\nTypically, neurons are organized in layers. Different layers may perform different kinds of transformations on their inputs. Signals travel from the first (input), to the last (output) layer, possibly after traversing the layers multiple times.\n\nThe original goal of the neural network approach was to solve problems in the same way that a human brain would. Over time, attention focused on matching specific mental abilities, leading to deviations from biology such as backpropagation, or passing information in the reverse direction and adjusting the network to reflect that information.\n\nNeural networks have been used on a variety of tasks, including computer vision, speech recognition, machine translation, social network filtering, playing board and video games and medical diagnosis.\n\nAs of 2017, neural networks typically have a few thousand to a few million units and millions of connections. Despite this number being several order of magnitude less than the number of neurons on a human brain, these networks can perform many tasks at a level beyond that of humans (e.g., recognizing faces, playing \\\"Go\\\"[99] ).\n\nDeep neural networks\n\nThis section may be too technical for most readers to understand. Please help improve it to make it understandable to non-experts, without removing the technical details. (July 2016) (Learn how and when to remove this template message)\nA deep neural network (DNN) is an artificial neural network (ANN) with multiple layers between the input and output layers.[11][2] The DNN finds the correct mathematical manipulation to turn the input into the output, whether it be a linear relationship or a non-linear relationship. The network moves through the layers calculating the probability of each output. For example, a DNN that is trained to recognize dog breeds will go over the given image and calculate the probability that the dog in the image is a certain breed. The user can review the results and select which probabilities the network should display (above a certain threshold, etc.) and return the proposed label. Each mathematical manipulation as such is considered a layer, and complex DNN have many layers, hence the name \\\"deep\\\" networks. The goal is that eventually, the network will be trained to decompose an image into features, identify trends that exist across all samples and classify new images by their similarities without requiring human input.[100]\n\nDNNs can model complex non-linear relationships. DNN architectures generate compositional models where the object is expressed as a layered composition of primitives.[101] The extra layers enable composition of features from lower layers, potentially modeling complex data with fewer units than a similarly performing shallow network.[11]\n\nDeep architectures include many variants of a few basic approaches. Each architecture has found success in specific domains. It is not always possible to compare the performance of multiple architectures, unless they have been evaluated on the same data sets.\n\nDNNs are typically feedforward networks in which data flows from the input layer to the output layer without looping back. At first, the DNN creates a map of virtual neurons and assigns random numerical values, or \\\"weights\\\", to connections between them. The weights and inputs are multiplied and return an output between 0 and 1. If the network didn\u2019t accurately recognize a particular pattern, an algorithm would adjust the weights.[102] That way the algorithm can make certain parameters more influential, until it determines the correct mathematical manipulation to fully process the data.\n\nRecurrent neural networks (RNNs), in which data can flow in any direction, are used for applications such as language modeling.[103][104][105][106][107] Long short-term memory is particularly effective for this use.[50][108]\n\nConvolutional deep neural networks (CNNs) are used in computer vision.[109] CNNs also have been applied to acoustic modeling for automatic speech recognition (ASR).[66]\n\nChallenges\nAs with ANNs, many issues can arise with naively trained DNNs. Two common issues are overfitting and computation time.\n\nDNNs are prone to overfitting because of the added layers of abstraction, which allow them to model rare dependencies in the training data. Regularization methods such as Ivakhnenko\\'s unit pruning[28] or weight decay ( {\\displaystyle \\ell _{2}} \\ell _{2}-regularization) or sparsity ( {\\displaystyle \\ell _{1}} \\ell _{1}-regularization) can be applied during training to combat overfitting.[110] Alternatively dropout regularization randomly omits units from the hidden layers during training. This helps to exclude rare dependencies.[111] Finally, data can be augmented via methods such as cropping and rotating such that smaller training sets can be increased in size to reduce the chances of overfitting.[112]\n\nDNNs must consider many training parameters, such as the size (number of layers and number of units per layer), the learning rate, and initial weights. Sweeping through the parameter space for optimal parameters may not be feasible due to the cost in time and computational resources. Various tricks, such as batching (computing the gradient on several training examples at once rather than individual examples)[113] speed up computation. Large processing capabilities of many-core architectures (such as, GPUs or the Intel Xeon Phi) have produced significant speedups in training, because of the suitability of such processing architectures for the matrix and vector computations.[114][115]\n\nAlternatively, engineers may look for other types of neural networks with more straightforward and convergent training algorithms. CMAC (cerebellar model articulation controller) is one such kind of neural network. It doesn\\'t require learning rates or randomized initial weights for CMAC. The training process can be guaranteed to converge in one step with a new batch of data, and the computational complexity of the training algorithm is linear with respect to the number of neurons involved.[116][117]\n\nApplications\n\nIt has been suggested that this section be split out into another article titled Applications of Deep Learning. (Discuss) (June 2018)\nAutomatic speech recognition\nMain article: Speech recognition\nLarge-scale automatic speech recognition is the first and most convincing successful case of deep learning. LSTM RNNs can learn \\\"Very Deep Learning\\\" tasks[2] that involve multi-second intervals containing speech events separated by thousands of discrete time steps, where one time step corresponds to about 10 ms. LSTM with forget gates[108] is competitive with traditional speech recognizers on certain tasks.[51]\n\nThe initial success in speech recognition was based on small-scale recognition tasks based on TIMIT. The data set contains 630 speakers from eight major dialects of American English, where each speaker reads 10 sentences.[118] Its small size lets many configurations be tried. More importantly, the TIMIT task concerns phone-sequence recognition, which, unlike word-sequence recognition, allows weak phone bigram language models. This lets the strength of the acoustic modeling aspects of speech recognition be more easily analyzed. The error rates listed below, including these early results and measured as percent phone error rates (PER), have been summarized since 1991.\n\nMethod\tPER (%)\nRandomly Initialized RNN[119]\t26.1\nBayesian Triphone GMM-HMM\t25.6\nHidden Trajectory (Generative) Model\t24.8\nMonophone Randomly Initialized DNN\t23.4\nMonophone DBN-DNN\t22.4\nTriphone GMM-HMM with BMMI Training\t21.7\nMonophone DBN-DNN on fbank\t20.7\nConvolutional DNN[120]\t20.0\nConvolutional DNN w. Heterogeneous Pooling\t18.7\nEnsemble DNN/CNN/RNN[121]\t18.3\nBidirectional LSTM\t17.9\nHierarchical Convolutional Deep Maxout Network[122]\t16.5\nThe debut of DNNs for speaker recognition in the late 1990s and speech recognition around 2009-2011 and of LSTM around 2003-2007, accelerated progress in eight major areas:[10][74][72]\n\nScale-up/out and acclerated DNN training and decoding\nSequence discriminative training\nFeature processing by deep models with solid understanding of the underlying mechanisms\nAdaptation of DNNs and related deep models\nMulti-task and transfer learning by DNNs and related deep models\nCNNs and how to design them to best exploit domain knowledge of speech\nRNN and its rich LSTM variants\nOther types of deep models including tensor-based models and integrated deep generative/discriminative models.\nAll major commercial speech recognition systems (e.g., Microsoft Cortana, Xbox, Skype Translator, Amazon Alexa, Google Now, Apple Siri, Baidu and iFlyTek voice search, and a range of Nuance speech products, etc.) are based on deep learning.[10][123][124][125]\n\nImage recognition\nMain article: Computer vision\nA common evaluation set for image classification is the MNIST database data set. MNIST is composed of handwritten digits and includes 60,000 training examples and 10,000 test examples. As with TIMIT, its small size lets users test multiple configurations. A comprehensive list of results on this set is available.[126]\n\nDeep learning-based image recognition has become \\\"superhuman\\\", producing more accurate results than human contestants. This first occurred in 2011.[127]\n\nDeep learning-trained vehicles now interpret 360\u00b0 camera views.[128] Another example is Facial Dysmorphology Novel Analysis (FDNA) used to analyze cases of human malformation connected to a large database of genetic syndromes.\n\nVisual art processing\nClosely related to the progress that has been made in image recognition is the increasing application of deep learning techniques to various visual art tasks. DNNs have proven themselves capable, for example, of a) identifying the style period of a given painting, b) \\\"capturing\\\" the style of a given painting and applying it in a visually pleasing manner to an arbitrary photograph, and c) generating striking imagery based on random visual input fields.[129][130]\n\nNatural language processing\nMain article: Natural language processing\nNeural networks have been used for implementing language models since the early 2000s.[103][131] LSTM helped to improve machine translation and language modeling.[104][105][106]\n\nOther key techniques in this field are negative sampling[132] and word embedding. Word embedding, such as word2vec, can be thought of as a representational layer in a deep learning architecture that transforms an atomic word into a positional representation of the word relative to other words in the dataset; the position is represented as a point in a vector space. Using word embedding as an RNN input layer allows the network to parse sentences and phrases using an effective compositional vector grammar. A compositional vector grammar can be thought of as probabilistic context free grammar (PCFG) implemented by an RNN.[133] Recursive auto-encoders built atop word embeddings can assess sentence similarity and detect paraphrasing.[133] Deep neural architectures provide the best results for constituency parsing,[134] sentiment analysis,[135] information retrieval,[136][137] spoken language understanding,[138] machine translation,[104][139] contextual entity linking,[139] writing style recognition,[140] Text classification and others.[141]\n\nRecent developments generalize word embedding to sentence embedding.\n\nGoogle Translate (GT) uses a large end-to-end long short-term memory network.[142][143][144][145][146][147] Google Neural Machine Translation (GNMT) uses an example-based machine translation method in which the system \\\"learns from millions of examples.\\\"[143] It translates \\\"whole sentences at a time, rather than pieces. Google Translate supports over one hundred languages.[143] The network encodes the \\\"semantics of the sentence rather than simply memorizing phrase-to-phrase translations\\\".[143][148] GT uses English as an intermediate between most language pairs.[148]\n\nDrug discovery and toxicology\nFor more information, see Drug discovery and Toxicology.\nA large percentage of candidate drugs fail to win regulatory approval. These failures are caused by insufficient efficacy (on-target effect), undesired interactions (off-target effects), or unanticipated toxic effects.[149][150] Research has explored use of deep learning to predict the biomolecular targets,[85][86] off-targets, and toxic effects of environmental chemicals in nutrients, household products and drugs.[87][88][89]\n\nAtomNet is a deep learning system for structure-based rational drug design.[151] AtomNet was used to predict novel candidate biomolecules for disease targets such as the Ebola virus[152] and multiple sclerosis.[153][154]\n\nCustomer relationship management\nMain article: Customer relationship management\nDeep reinforcement learning has been used to approximate the value of possible direct marketing actions, defined in terms of RFM variables. The estimated value function was shown to have a natural interpretation as customer lifetime value.[155]\n\nRecommendation systems\nMain article: Recommender system\nRecommendation systems have used deep learning to extract meaningful features for a latent factor model for content-based music recommendations.[156] Multiview deep learning has been applied for learning user preferences from multiple domains.[157] The model uses a hybrid collaborative and content-based approach and enhances recommendations in multiple tasks.\n\nBioinformatics\nMain article: Bioinformatics\nAn autoencoder ANN was used in bioinformatics, to predict gene ontology annotations and gene-function relationships.[158]\n\nIn medical informatics, deep learning was used to predict sleep quality based on data from wearables[159] and predictions of health complications from electronic health record data.[160] Deep learning has also showed efficacy in healthcare.[161]\n\nMobile advertising\nFinding the appropriate mobile audience for mobile advertising is always challenging, since many data points must be considered and assimilated before a target segment can be created and used in ad serving by any ad server.[162][163] Deep learning has been used to interpret large, many-dimensioned advertising datasets. Many data points are collected during the request/serve/click internet advertising cycle. This information can form the basis of machine learning to improve ad selection.\n\nImage restoration\nDeep learning has been successfully applied to inverse problems such as denoising, super-resolution, inpainting, and film colorization. These applications include learning methods such as \\\"Shrinkage Fields for Effective Image Restoration\\\"[164] which trains on an image dataset, and Deep Image Prior, which trains on the image that needs restoration.\n\nFinancial fraud detection\nDeep learning is being successfully applied to financial fraud detection and anti-money laundering. \\\"Deep anti-money laundering detection system can spot and recognize relationships and similarities between data and, further down the road, learn to detect anomalies or classify and predict specific events\\\". The solution leverages both supervised learning techniques, such as the classification of suspicious transactions, and unsupervised learning, e.g. anomaly detection. [165]\n\nMilitary\nThe Department of Defense applied deep learning to train robots in new tasks through observation.[166]\n\nRelation to human cognitive and brain development\nDeep learning is closely related to a class of theories of brain development (specifically, neocortical development) proposed by cognitive neuroscientists in the early 1990s.[167][168][169][170] These developmental theories were instantiated in computational models, making them predecessors of deep learning systems. These developmental models share the property that various proposed learning dynamics in the brain (e.g., a wave of nerve growth factor) support the self-organization somewhat analogous to the neural networks utilized in deep learning models. Like the neocortex, neural networks employ a hierarchy of layered filters in which each layer considers information from a prior layer (or the operating environment), and then passes its output (and possibly the original input), to other layers. This process yields a self-organizing stack of transducers, well-tuned to their operating environment. A 1995 description stated, \\\"...the infant\\'s brain seems to organize itself under the influence of waves of so-called trophic-factors ... different regions of the brain become connected sequentially, with one layer of tissue maturing before another and so on until the whole brain is mature.\\\"[171]\n\nA variety of approaches have been used to investigate the plausibility of deep learning models from a neurobiological perspective. On the one hand, several variants of the backpropagation algorithm have been proposed in order to increase its processing realism.[172][173] Other researchers have argued that unsupervised forms of deep learning, such as those based on hierarchical generative models and deep belief networks, may be closer to biological reality.[174][175] In this respect, generative neural network models have been related to neurobiological evidence about sampling-based processing in the cerebral cortex.[176]\n\nAlthough a systematic comparison between the human brain organization and the neuronal encoding in deep networks has not yet been established, several analogies have been reported. For example, the computations performed by deep learning units could be similar to those of actual neurons[177][178] and neural populations.[179] Similarly, the representations developed by deep learning models are similar to those measured in the primate visual system[180] both at the single-unit[181] and at the population[182] levels.\n\nCommercial activity\nMany organizations employ deep learning for particular applications. Facebook\\'s AI lab performs tasks such as automatically tagging uploaded pictures with the names of the people in them.[183]\n\nGoogle\\'s DeepMind Technologies developed a system capable of learning how to play Atari video games using only pixels as data input. In 2015 they demonstrated their AlphaGo system, which learned the game of Go well enough to beat a professional Go player.[184][185][186] Google Translate uses an LSTM to translate between more than 100 languages.\n\nIn 2015, Blippar demonstrated a mobile augmented reality application that uses deep learning to recognize objects in real time.[187]\n\nAs of 2008,[188] researchers at The University of Texas at Austin (UT) developed a machine learning framework called Training an Agent Manually via Evaluative Reinforcement, or TAMER, which proposed new methods for robots or computer programs to learn how to perform tasks by interacting with a human instructor.[166]\n\nFirst developed as TAMER, a new algorithm called Deep TAMER was later introduced in 2018 during a collaboration between U.S. Army Research Laboratory (ARL) and UT researchers. Deep TAMER used deep learning to provide a robot the ability to learn new tasks through observation.[166]\n\nUsing Deep TAMER, a robot learned a task with a human trainer, watching video streams or observing a human perform a task in-person. The robot later practiced the task with the help of some coaching from the trainer, who provided feedback such as \u201cgood job\u201d and \u201cbad job.\u201d[189]\n\nCriticism and comment\nDeep learning has attracted both criticism and comment, in some cases from outside the field of computer science.\n\nTheory\nSee also: Explainable AI\nA main criticism concerns the lack of theory surrounding some methods.[190] Learning in the most common deep architectures is implemented using well-understood gradient descent. However, the theory surrounding other algorithms, such as contrastive divergence is less clear.[citation needed] (e.g., Does it converge? If so, how fast? What is it approximating?) Deep learning methods are often looked at as a black box, with most confirmations done empirically, rather than theoretically.[191]\n\nOthers point out that deep learning should be looked at as a step towards realizing strong AI, not as an all-encompassing solution. Despite the power of deep learning methods, they still lack much of the functionality needed for realizing this goal entirely. Research psychologist Gary Marcus noted:\n\n\\\"Realistically, deep learning is only part of the larger challenge of building intelligent machines. Such techniques lack ways of representing causal relationships (...) have no obvious ways of performing logical inferences, and they are also still a long way from integrating abstract knowledge, such as information about what objects are, what they are for, and how they are typically used. The most powerful A.I. systems, like Watson (...) use techniques like deep learning as just one element in a very complicated ensemble of techniques, ranging from the statistical technique of Bayesian inference to deductive reasoning.\\\"[192]\n\nAs an alternative to this emphasis on the limits of deep learning, one author speculated that it might be possible to train a machine vision stack to perform the sophisticated task of discriminating between \\\"old master\\\" and amateur figure drawings, and hypothesized that such a sensitivity might represent the rudiments of a non-trivial machine empathy.[193] This same author proposed that this would be in line with anthropology, which identifies a concern with aesthetics as a key element of behavioral modernity.[194]\n\nIn further reference to the idea that artistic sensitivity might inhere within relatively low levels of the cognitive hierarchy, a published series of graphic representations of the internal states of deep (20-30 layers) neural networks attempting to discern within essentially random data the images on which they were trained[195] demonstrate a visual appeal: the original research notice received well over 1,000 comments, and was the subject of what was for a time the most frequently accessed article on The Guardian\\'s[196] web site.\n\nErrors\nSome deep learning architectures display problematic behaviors,[197] such as confidently classifying unrecognizable images as belonging to a familiar category of ordinary images[198] and misclassifying minuscule perturbations of correctly classified images.[199] Goertzel hypothesized that these behaviors are due to limitations in their internal representations and that these limitations would inhibit integration into heterogeneous multi-component AGI architectures.[197] These issues may possibly be addressed by deep learning architectures that internally form states homologous to image-grammar[200] decompositions of observed entities and events.[197] Learning a grammar (visual or linguistic) from training data would be equivalent to restricting the system to commonsense reasoning that operates on concepts in terms of grammatical production rules and is a basic goal of both human language acquisition[201] and AI.[202]\n\nCyberthreat\nAs deep learning moves from the lab into the world, research and experience shows that artificial neural networks are vulnerable to hacks and deception. By identifying patterns that these systems use to function, attackers can modify inputs to ANNs in such a way that the ANN finds a match that human observers would not recognize. For example, an attacker can make subtle changes to an image such that the ANN finds a match even though the image looks to a human nothing like the search target. Such a manipulation is termed an \u201cadversarial attack.\u201d In 2016 researchers used one ANN to doctor images in trial and error fashion, identify another\\'s focal points and thereby generate images that deceived it. The modified images looked no different to human eyes. Another group showed that printouts of doctored images then photographed successfully tricked an image classification system.[203] One defense is reverse image search, in which a possible fake image is submitted to a site such as TinEye that can then find other instances of it. A refinement is to search using only parts of the image, to identify images from which that piece may have been taken.[204]\n\nAnother group showed that certain psychedelic spectacles could fool a facial recognition system into thinking ordinary people were celebrities, potentially allowing one person to impersonate another. In 2017 researchers added stickers to stop signs and caused an ANN to misclassify them.[203]\n\nANNs can however be further trained to detect attempts at deception, potentially leading attackers and defenders into an arms race similar to the kind that already defines the malware defense industry. ANNs have been trained to defeat ANN-based anti-malware software by repeatedly attacking a defense with malware that was continually altered by a genetic algorithm until it tricked the anti-malware while retaining its ability to damage the target.[203]\n\nAnother group demonstrated that certain sounds could make the Google Now voice command system open a particular web address that would download malware.[203]\n\nIn \u201cdata poisoning\u201d, false data is continually smuggled into a machine learning system\u2019s training set to prevent it from achieving mastery.[203]\n\nArtificial neural networks (ANN) or connectionist systems are computing systems vaguely inspired by the biological neural networks that constitute animal brains.[1] The neural network itself is not an algorithm, but rather a framework for many different machine learning algorithms to work together and process complex data inputs.[2] Such systems \\\"learn\\\" to perform tasks by considering examples, generally without being programmed with any task-specific rules. For example, in image recognition, they might learn to identify images that contain cats by analyzing example images that have been manually labeled as \\\"cat\\\" or \\\"no cat\\\" and using the results to identify cats in other images. They do this without any prior knowledge about cats, for example, that they have fur, tails, whiskers and cat-like faces. Instead, they automatically generate identifying characteristics from the learning material that they process.\n\nAn ANN is based on a collection of connected units or nodes called artificial neurons, which loosely model the neurons in a biological brain. Each connection, like the synapses in a biological brain, can transmit a signal from one artificial neuron to another. An artificial neuron that receives a signal can process it and then signal additional artificial neurons connected to it.\n\nIn common ANN implementations, the signal at a connection between artificial neurons is a real number, and the output of each artificial neuron is computed by some non-linear function of the sum of its inputs. The connections between artificial neurons are called \\'edges\\'. Artificial neurons and edges typically have a weight that adjusts as learning proceeds. The weight increases or decreases the strength of the signal at a connection. Artificial neurons may have a threshold such that the signal is only sent if the aggregate signal crosses that threshold. Typically, artificial neurons are aggregated into layers. Different layers may perform different kinds of transformations on their inputs. Signals travel from the first layer (the input layer), to the last layer (the output layer), possibly after traversing the layers multiple times.\n\nThe original goal of the ANN approach was to solve problems in the same way that a human brain would. However, over time, attention moved to performing specific tasks, leading to deviations from biology. Artificial neural networks have been used on a variety of tasks, including computer vision, speech recognition, machine translation, social network filtering, playing board and video games and medical diagnosis.\n\n\nContents\n1\tHistory\n1.1\tHebbian learning\n1.2\tBackpropagation\n1.3\tHardware-based designs\n1.4\tContests\n1.5\tConvolutional networks\n2\tModels\n2.1\tComponents of an artificial neural network\n2.2\tNeural networks as functions\n2.3\tLearning\n2.4\tLearning paradigms\n2.5\tLearning algorithms\n3\tVariants\n3.1\tGroup method of data handling\n3.2\tConvolutional neural networks\n3.3\tLong short-term memory\n3.4\tDeep reservoir computing\n3.5\tDeep belief networks\n3.6\tLarge memory storage and retrieval neural networks\n3.7\tStacked (de-noising) auto-encoders\n3.8\tDeep stacking networks\n3.9\tTensor deep stacking networks\n3.10\tSpike-and-slab RBMs\n3.11\tCompound hierarchical-deep models\n3.12\tDeep predictive coding networks\n3.13\tNetworks with separate memory structures\n3.14\tMultilayer kernel machine\n4\tNeural architecture search\n5\tUse\n6\tApplications\n6.1\tTypes of models\n7\tTheoretical properties\n7.1\tComputational power\n7.2\tCapacity\n7.3\tConvergence\n7.4\tGeneralization and statistics\n8\tCriticism\n8.1\tTraining issues\n8.2\tTheoretical issues\n8.3\tHardware issues\n8.4\tPractical counterexamples to criticisms\n8.5\tHybrid approaches\n9\tTypes\n10\tGallery\n11\tSee also\n12\tReferences\n13\tBibliography\n14\tExternal links\nHistory\nWarren McCulloch and Walter Pitts[3] (1943) created a computational model for neural networks based on mathematics and algorithms called threshold logic. This model paved the way for neural network research to split into two approaches. One approach focused on biological processes in the brain while the other focused on the application of neural networks to artificial intelligence. This work led to work on nerve networks and their link to finite automata.[4]\n\nHebbian learning\nIn the late 1940s, D. O. Hebb[5] created a learning hypothesis based on the mechanism of neural plasticity that became known as Hebbian learning. Hebbian learning is unsupervised learning. This evolved into models for long term potentiation. Researchers started applying these ideas to computational models in 1948 with Turing\\'s B-type machines.\n\nFarley and Clark[6] (1954) first used computational machines, then called \\\"calculators\\\", to simulate a Hebbian network. Other neural network computational machines were created by Rochester, Holland, Habit and Duda (1956).[7]\n\nRosenblatt[8] (1958) created the perceptron, an algorithm for pattern recognition. With mathematical notation, Rosenblatt described circuitry not in the basic perceptron, such as the exclusive-or circuit that could not be processed by neural networks at the time.[9]\n\nIn 1959, a biological model proposed by Nobel laureates Hubel and Wiesel was based on their discovery of two types of cells in the primary visual cortex: simple cells and complex cells.[10]\n\nThe first functional networks with many layers were published by Ivakhnenko and Lapa in 1965, becoming the Group Method of Data Handling.[11][12][13]\n\nNeural network research stagnated after machine learning research by Minsky and Papert (1969),[14] who discovered two key issues with the computational machines that processed neural networks. The first was that basic perceptrons were incapable of processing the exclusive-or circuit. The second was that computers didn\\'t have enough processing power to effectively handle the work required by large neural networks. Neural network research slowed until computers achieved far greater processing power.\n\nMuch of artificial intelligence had focused on high-level (symbolic) models that are processed by using algorithms, characterized for example by expert systems with knowledge embodied in if-then rules, until in the late 1980s research expanded to low-level (sub-symbolic) machine learning, characterized by knowledge embodied in the parameters of a cognitive model.[citation needed]\n\nBackpropagation\nA key trigger for renewed interest in neural networks and learning was Werbos\\'s (1975) backpropagation algorithm that effectively solved the exclusive-or problem by making the training of multi-layer networks feasible and efficient. Backpropagation distributed the error term back up through the layers, by modifying the weights at each node.[9]\n\nIn the mid-1980s, parallel distributed processing became popular under the name connectionism. Rumelhart and McClelland (1986) described the use of connectionism to simulate neural processes.[15]\n\nSupport vector machines and other, much simpler methods such as linear classifiers gradually overtook neural networks in machine learning popularity. However, using neural networks transformed some domains, such as the prediction of protein structures.[16][17]\n\nIn 1992, max-pooling was introduced to help with least shift invariance and tolerance to deformation to aid in 3D object recognition.[18][19][20] In 2010, Backpropagation training through max-pooling was accelerated by GPUs and shown to perform better than other pooling variants.[21]\n\nThe vanishing gradient problem affects many-layered feedforward networks that used backpropagation and also recurrent neural networks (RNNs).[22][23] As errors propagate from layer to layer, they shrink exponentially with the number of layers, impeding the tuning of neuron weights that is based on those errors, particularly affecting deep networks.\n\nTo overcome this problem, Schmidhuber adopted a multi-level hierarchy of networks (1992) pre-trained one level at a time by unsupervised learning and fine-tuned by backpropagation.[24] Behnke (2003) relied only on the sign of the gradient (Rprop)[25] on problems such as image reconstruction and face localization.\n\nHinton et al. (2006) proposed learning a high-level representation using successive layers of binary or real-valued latent variables with a restricted Boltzmann machine[26] to model each layer. Once sufficiently many layers have been learned, the deep architecture may be used as a generative model by reproducing the data when sampling down the model (an \\\"ancestral pass\\\") from the top level feature activations.[27][28] In 2012, Ng and Dean created a network that learned to recognize higher-level concepts, such as cats, only from watching unlabeled images taken from YouTube videos.[29]\n\nEarlier challenges in training deep neural networks were successfully addressed with methods such as unsupervised pre-training, while available computing power increased through the use of GPUs and distributed computing. Neural networks were deployed on a large scale, particularly in image and visual recognition problems. This became known as \\\"deep learning\\\".[citation needed]\n\nHardware-based designs\nComputational devices were created in CMOS, for both biophysical simulation and neuromorphic computing. Nanodevices[30] for very large scale principal components analyses and convolution may create a new class of neural computing because they are fundamentally analog rather than digital (even though the first implementations may use digital devices).[31] Ciresan and colleagues (2010)[32] in Schmidhuber\\'s group showed that despite the vanishing gradient problem, GPUs makes back-propagation feasible for many-layered feedforward neural networks.\n\nContests\nBetween 2009 and 2012, recurrent neural networks and deep feedforward neural networks developed in Schmidhuber\\'s research group won eight international competitions in pattern recognition and machine learning.[33][34] For example, the bi-directional and multi-dimensional long short-term memory (LSTM)[35][36][37][38] of Graves et al. won three competitions in connected handwriting recognition at the 2009 International Conference on Document Analysis and Recognition (ICDAR), without any prior knowledge about the three languages to be learned.[37][36]\n\nCiresan and colleagues won pattern recognition contests, including the IJCNN 2011 Traffic Sign Recognition Competition,[39] the ISBI 2012 Segmentation of Neuronal Structures in Electron Microscopy Stacks challenge[40] and others. Their neural networks were the first pattern recognizers to achieve human-competitive or even superhuman performance[41] on benchmarks such as traffic sign recognition (IJCNN 2012), or the MNIST handwritten digits problem.\n\nResearchers demonstrated (2010) that deep neural networks interfaced to a hidden Markov model with context-dependent states that define the neural network output layer can drastically reduce errors in large-vocabulary speech recognition tasks such as voice search.\n\nGPU-based implementations[42] of this approach won many pattern recognition contests, including the IJCNN 2011 Traffic Sign Recognition Competition,[39] the ISBI 2012 Segmentation of neuronal structures in EM stacks challenge,[40] the ImageNet Competition[43] and others.\n\nDeep, highly nonlinear neural architectures similar to the neocognitron[44] and the \\\"standard architecture of vision\\\",[45] inspired by simple and complex cells, were pre-trained by unsupervised methods by Hinton.[46][27] A team from his lab won a 2012 contest sponsored by Merck to design software to help find molecules that might identify new drugs.[47]\n\nConvolutional networks\nAs of 2011, the state of the art in deep learning feedforward networks alternated between convolutional layers and max-pooling layers,[42][48] topped by several fully or sparsely connected layers followed by a final classification layer. Learning is usually done without unsupervised pre-training. In the convolutional layer, there are filters that are convolved with the input. Each filter is equivalent to a weights vector that has to be trained.\n\nSuch supervised deep learning methods were the first to achieve human-competitive performance on certain tasks.[41]\n\nArtificial neural networks were able to guarantee shift invariance to deal with small and large natural objects in large cluttered scenes, only when invariance extended beyond shift, to all ANN-learned concepts, such as location, type (object class label), scale, lighting and others. This was realized in Developmental Networks (DNs)[49] whose embodiments are Where-What Networks, WWN-1 (2008)[50] through WWN-7 (2013).[51]\n\nModels\n\nThis section may be confusing or unclear to readers. Please help us clarify the section. There might be a discussion about this on the talk page. (April 2017) (Learn how and when to remove this template message)\n\nNeuron and myelinated axon, with signal flow from inputs at dendrites to outputs at axon terminals\nAn artificial neural network is a network of simple elements called artificial neurons, which receive input, change their internal state (activation) according to that input, and produce output depending on the input and activation.\n\nAn artificial neuron mimics the working of a biophysical neuron with inputs and outputs, but is not a biological neuron model.\n\nThe network forms by connecting the output of certain neurons to the input of other neurons forming a directed, weighted graph. The weights as well as the functions that compute the activation can be modified by a process called learning which is governed by a learning rule.[52]\n\nComponents of an artificial neural network\nNeurons\nA neuron with label {\\displaystyle j} j receiving an input {\\displaystyle p_{j}(t)} {\\displaystyle p_{j}(t)} from predecessor neurons consists of the following components:[52]\n\nan activation {\\displaystyle a_{j}(t)} {\\displaystyle a_{j}(t)}, the neuron\\'s state, depending on a discrete time parameter,\npossibly a threshold {\\displaystyle \\theta _{j}} \\theta _{j}, which stays fixed unless changed by a learning function,\nan activation function {\\displaystyle f} f that computes the new activation at a given time {\\displaystyle t+1} t+1 from {\\displaystyle a_{j}(t)} {\\displaystyle a_{j}(t)}, {\\displaystyle \\theta _{j}} \\theta _{j} and the net input {\\displaystyle p_{j}(t)} {\\displaystyle p_{j}(t)} giving rise to the relation\n{\\displaystyle a_{j}(t+1)=f(a_{j}(t),p_{j}(t),\\theta _{j})} {\\displaystyle a_{j}(t+1)=f(a_{j}(t),p_{j}(t),\\theta _{j})},\nand an output function {\\displaystyle f_{out}} {\\displaystyle f_{out}} computing the output from the activation\n{\\displaystyle o_{j}(t)=f_{out}(a_{j}(t))} {\\displaystyle o_{j}(t)=f_{out}(a_{j}(t))}.\nOften the output function is simply the Identity function.\n\nAn input neuron has no predecessor but serves as input interface for the whole network. Similarly an output neuron has no successor and thus serves as output interface of the whole network.\n\nConnections, weights and biases\nThe network consists of connections, each connection transferring the output of a neuron {\\displaystyle i} i to the input of a neuron {\\displaystyle j} j. In this sense {\\displaystyle i} i is the predecessor of {\\displaystyle j} j and {\\displaystyle j} j is the successor of {\\displaystyle i} i. Each connection is assigned a weight {\\displaystyle w_{ij}} w_{ij}.[52] Sometimes a bias term added to total weighted sum of inputs to serve as threshold to shift the activation function.[53]\n\nPropagation function\nThe propagation function computes the input {\\displaystyle p_{j}(t)} {\\displaystyle p_{j}(t)} to the neuron {\\displaystyle j} j from the outputs {\\displaystyle o_{i}(t)} {\\displaystyle o_{i}(t)} of predecessor neurons and typically has the form[52]\n\n{\\displaystyle p_{j}(t)=\\sum _{i}o_{i}(t)w_{ij}} {\\displaystyle p_{j}(t)=\\sum _{i}o_{i}(t)w_{ij}}.\nWhen a bias value added with the function, the above form changes to following [54]\n\n{\\displaystyle p_{j}(t)=\\sum _{i}o_{i}(t)w_{ij}+w_{0j}} {\\displaystyle p_{j}(t)=\\sum _{i}o_{i}(t)w_{ij}+w_{0j}} , where {\\displaystyle w_{0j}} {\\displaystyle w_{0j}} is a bias.\nLearning rule\nThe learning rule is a rule or an algorithm which modifies the parameters of the neural network, in order for a given input to the network to produce a favored output. This learning process typically amounts to modifying the weights and thresholds of the variables within the network.[52]\n\nNeural networks as functions\nSee also: Graphical models\nNeural network models can be viewed as simple mathematical models defining a function {\\displaystyle \\textstyle f:X\\rightarrow Y} {\\displaystyle \\textstyle f:X\\rightarrow Y} or a distribution over {\\displaystyle \\textstyle X} \\textstyle X or both {\\displaystyle \\textstyle X} \\textstyle X and {\\displaystyle \\textstyle Y} \\textstyle Y. Sometimes models are intimately associated with a particular learning rule. A common use of the phrase \\\"ANN model\\\" is really the definition of a class of such functions (where members of the class are obtained by varying parameters, connection weights, or specifics of the architecture such as the number of neurons or their connectivity).\n\nMathematically, a neuron\\'s network function {\\displaystyle \\textstyle f(x)} \\textstyle f(x) is defined as a composition of other functions {\\displaystyle \\textstyle g_{i}(x)} \\textstyle g_{i}(x), that can further be decomposed into other functions. This can be conveniently represented as a network structure, with arrows depicting the dependencies between functions. A widely used type of composition is the nonlinear weighted sum, where {\\displaystyle \\textstyle f(x)=K\\left(\\sum _{i}w_{i}g_{i}(x)\\right)} \\textstyle f(x)=K\\left(\\sum _{i}w_{i}g_{i}(x)\\right), where {\\displaystyle \\textstyle K} \\textstyle K (commonly referred to as the activation function[55]) is some predefined function, such as the hyperbolic tangent or sigmoid function or softmax function or rectifier function. The important characteristic of the activation function is that it provides a smooth transition as input values change, i.e. a small change in input produces a small change in output. The following refers to a collection of functions {\\displaystyle \\textstyle g_{i}} \\textstyle g_{i} as a vector {\\displaystyle \\textstyle g=(g_{1},g_{2},\\ldots ,g_{n})} \\textstyle g=(g_{1},g_{2},\\ldots ,g_{n}).\n\n\nANN dependency graph\nThis figure depicts such a decomposition of {\\displaystyle \\textstyle f} \\textstyle f, with dependencies between variables indicated by arrows. These can be interpreted in two ways.\n\nThe first view is the functional view: the input {\\displaystyle \\textstyle x} \\textstyle x is transformed into a 3-dimensional vector {\\displaystyle \\textstyle h} \\textstyle h, which is then transformed into a 2-dimensional vector {\\displaystyle \\textstyle g} \\textstyle g, which is finally transformed into {\\displaystyle \\textstyle f} \\textstyle f. This view is most commonly encountered in the context of optimization.\n\nThe second view is the probabilistic view: the random variable {\\displaystyle \\textstyle F=f(G)} \\textstyle F=f(G) depends upon the random variable {\\displaystyle \\textstyle G=g(H)} \\textstyle G=g(H), which depends upon {\\displaystyle \\textstyle H=h(X)} \\textstyle H=h(X), which depends upon the random variable {\\displaystyle \\textstyle X} \\textstyle X. This view is most commonly encountered in the context of graphical models.\n\nThe two views are largely equivalent. In either case, for this particular architecture, the components of individual layers are independent of each other (e.g., the components of {\\displaystyle \\textstyle g} \\textstyle g are independent of each other given their input {\\displaystyle \\textstyle h} \\textstyle h). This naturally enables a degree of parallelism in the implementation.\n\n\nTwo separate depictions of the recurrent ANN dependency graph\nNetworks such as the previous one are commonly called feedforward, because their graph is a directed acyclic graph. Networks with cycles are commonly called recurrent. Such networks are commonly depicted in the manner shown at the top of the figure, where {\\displaystyle \\textstyle f} \\textstyle f is shown as being dependent upon itself. However, an implied temporal dependence is not shown.\n\nLearning\nSee also: Mathematical optimization, Estimation theory, and Machine learning\nThe possibility of learning has attracted the most interest in neural networks. Given a specific task to solve, and a class of functions {\\displaystyle \\textstyle F} \\textstyle F, learning means using a set of observations to find {\\displaystyle \\textstyle f^{*}\\in F} \\textstyle f^{*}\\in F which solves the task in some optimal sense.\n\nThis entails defining a cost function {\\displaystyle \\textstyle C:F\\rightarrow \\mathbb {R} } \\textstyle C:F\\rightarrow \\mathbb {R}  such that, for the optimal solution {\\displaystyle \\textstyle f^{*}} \\textstyle f^{*}, {\\displaystyle \\textstyle C(f^{*})\\leq C(f)} \\textstyle C(f^{*})\\leq C(f) {\\displaystyle \\textstyle \\forall f\\in F} \\textstyle \\forall f\\in F \u2013 i.e., no solution has a cost less than the cost of the optimal solution (see mathematical optimization).\n\nThe cost function {\\displaystyle \\textstyle C} \\textstyle C is an important concept in learning, as it is a measure of how far away a particular solution is from an optimal solution to the problem to be solved. Learning algorithms search through the solution space to find a function that has the smallest possible cost.\n\nFor applications where the solution is data dependent, the cost must necessarily be a function of the observations, otherwise the model would not relate to the data. It is frequently defined as a statistic to which only approximations can be made. As a simple example, consider the problem of finding the model {\\displaystyle \\textstyle f} \\textstyle f, which minimizes {\\displaystyle \\textstyle C=E\\left[(f(x)-y)^{2}\\right]} \\textstyle C=E\\left[(f(x)-y)^{2}\\right], for data pairs {\\displaystyle \\textstyle (x,y)} \\textstyle (x,y) drawn from some distribution {\\displaystyle \\textstyle {\\mathcal {D}}} \\textstyle {\\mathcal {D}}. In practical situations we would only have {\\displaystyle \\textstyle N} \\textstyle N samples from {\\displaystyle \\textstyle {\\mathcal {D}}} \\textstyle {\\mathcal {D}} and thus, for the above example, we would only minimize {\\displaystyle \\textstyle {\\hat {C}}={\\frac {1}{N}}\\sum _{i=1}^{N}(f(x_{i})-y_{i})^{2}} \\textstyle {\\hat {C}}={\\frac {1}{N}}\\sum _{i=1}^{N}(f(x_{i})-y_{i})^{2}. Thus, the cost is minimized over a sample of the data rather than the entire distribution.\n\nWhen {\\displaystyle \\textstyle N\\rightarrow \\infty } \\textstyle N\\rightarrow \\infty  some form of online machine learning must be used, where the cost is reduced as each new example is seen. While online machine learning is often used when {\\displaystyle \\textstyle {\\mathcal {D}}} \\textstyle {\\mathcal {D}} is fixed, it is most useful in the case where the distribution changes slowly over time. In neural network methods, some form of online machine learning is frequently used for finite datasets.\n\nChoosing a cost function\nWhile it is possible to define an ad hoc cost function, frequently a particular cost (function) is used, either because it has desirable properties (such as convexity) or because it arises naturally from a particular formulation of the problem (e.g., in a probabilistic formulation the posterior probability of the model can be used as an inverse cost). Ultimately, the cost function depends on the task.\n\nBackpropagation\nMain article: Backpropagation\nA DNN can be discriminatively trained with the standard backpropagation algorithm. Backpropagation is a method to calculate the gradient of the loss function (produces the cost associated with a given state) with respect to the weights in an ANN.\n\nThe basics of continuous backpropagation[11][56][57][58] were derived in the context of control theory by Kelley[59] in 1960 and by Bryson in 1961,[60] using principles of dynamic programming. In 1962, Dreyfus published a simpler derivation based only on the chain rule.[61] Bryson and Ho described it as a multi-stage dynamic system optimization method in 1969.[62][63] In 1970, Linnainmaa finally published the general method for automatic differentiation (AD) of discrete connected networks of nested differentiable functions.[64][65] This corresponds to the modern version of backpropagation which is efficient even when the networks are sparse.[11][56][66][67] In 1973, Dreyfus used backpropagation to adapt parameters of controllers in proportion to error gradients.[68] In 1974, Werbos mentioned the possibility of applying this principle to Artificial neural networks,[69] and in 1982, he applied Linnainmaa\\'s AD method to neural networks in the way that is widely used today.[56][70] In 1986, Rumelhart, Hinton and Williams noted that this method can generate useful internal representations of incoming data in hidden layers of neural networks.[71] In 1993, Wan was the first[11] to win an international pattern recognition contest through backpropagation.[72]\n\nThe weight updates of backpropagation can be done via stochastic gradient descent using the following equation:\n\n{\\displaystyle w_{ij}(t+1)=w_{ij}(t)+\\eta {\\frac {\\partial C}{\\partial w_{ij}}}+\\xi (t)} {\\displaystyle w_{ij}(t+1)=w_{ij}(t)+\\eta {\\frac {\\partial C}{\\partial w_{ij}}}+\\xi (t)}\nwhere, {\\displaystyle \\eta } \\eta  is the learning rate, {\\displaystyle C} C is the cost (loss) function and {\\displaystyle \\xi (t)} \\xi (t) a stochastic term. The choice of the cost function depends on factors such as the learning type (supervised, unsupervised, reinforcement, etc.) and the activation function. For example, when performing supervised learning on a multiclass classification problem, common choices for the activation function and cost function are the softmax function and cross entropy function, respectively. The softmax function is defined as {\\displaystyle p_{j}={\\frac {\\exp(x_{j})}{\\sum _{k}\\exp(x_{k})}}} p_{j}={\\frac {\\exp(x_{j})}{\\sum _{k}\\exp(x_{k})}} where {\\displaystyle p_{j}} p_{j} represents the class probability (output of the unit {\\displaystyle j} j) and {\\displaystyle x_{j}} x_{j} and {\\displaystyle x_{k}} x_{k} represent the total input to units {\\displaystyle j} j and {\\displaystyle k} k of the same level respectively. Cross entropy is defined as {\\displaystyle C=-\\sum _{j}d_{j}\\log(p_{j})} C=-\\sum _{j}d_{j}\\log(p_{j}) where {\\displaystyle d_{j}} d_{j} represents the target probability for output unit {\\displaystyle j} j and {\\displaystyle p_{j}} p_{j} is the probability output for {\\displaystyle j} j after applying the activation function.[73]\n\nThese can be used to output object bounding boxes in the form of a binary mask. They are also used for multi-scale regression to increase localization precision. DNN-based regression can learn features that capture geometric information in addition to serving as a good classifier. They remove the requirement to explicitly model parts and their relations. This helps to broaden the variety of objects that can be learned. The model consists of multiple layers, each of which has a rectified linear unit as its activation function for non-linear transformation. Some layers are convolutional, while others are fully connected. Every convolutional layer has an additional max pooling. The network is trained to minimize L2 error for predicting the mask ranging over the entire training set containing bounding boxes represented as masks.\n\nAlternatives to backpropagation include Extreme Learning Machines,[74] \\\"No-prop\\\" networks,[75] training without backtracking,[76] \\\"weightless\\\" networks,[77][78] and non-connectionist neural networks.\n\nLearning paradigms\nThe three major learning paradigms each correspond to a particular learning task. These are supervised learning, unsupervised learning and reinforcement learning.\n\nSupervised learning\nSupervised learning uses a set of example pairs {\\displaystyle (x,y),x\\in X,y\\in Y}  (x, y), x \\in X, y \\in Y and the aim is to find a function {\\displaystyle f:X\\rightarrow Y}  f : X \\rightarrow Y  in the allowed class of functions that matches the examples. In other words, we wish to infer the mapping implied by the data; the cost function is related to the mismatch between our mapping and the data and it implicitly contains prior knowledge about the problem domain.[79]\n\nA commonly used cost is the mean-squared error, which tries to minimize the average squared error between the network\\'s output, {\\displaystyle f(x)} f(x), and the target value {\\displaystyle y} y over all the example pairs. Minimizing this cost using gradient descent for the class of neural networks called multilayer perceptrons (MLP), produces the backpropagation algorithm for training neural networks.\n\nTasks that fall within the paradigm of supervised learning are pattern recognition (also known as classification) and regression (also known as function approximation). The supervised learning paradigm is also applicable to sequential data (e.g., for hand writing, speech and gesture recognition). This can be thought of as learning with a \\\"teacher\\\", in the form of a function that provides continuous feedback on the quality of solutions obtained thus far.\n\nUnsupervised learning\nIn unsupervised learning, some data {\\displaystyle \\textstyle x} \\textstyle x is given and the cost function to be minimized, that can be any function of the data {\\displaystyle \\textstyle x} \\textstyle x and the network\\'s output, {\\displaystyle \\textstyle f} \\textstyle f.\n\nThe cost function is dependent on the task (the model domain) and any a priori assumptions (the implicit properties of the model, its parameters and the observed variables).\n\nAs a trivial example, consider the model {\\displaystyle \\textstyle f(x)=a} \\textstyle f(x)=a where {\\displaystyle \\textstyle a} \\textstyle a is a constant and the cost {\\displaystyle \\textstyle C=E[(x-f(x))^{2}]} \\textstyle C=E[(x-f(x))^{2}]. Minimizing this cost produces a value of {\\displaystyle \\textstyle a} \\textstyle a that is equal to the mean of the data. The cost function can be much more complicated. Its form depends on the application: for example, in compression it could be related to the mutual information between {\\displaystyle \\textstyle x} \\textstyle x and {\\displaystyle \\textstyle f(x)} \\textstyle f(x), whereas in statistical modeling, it could be related to the posterior probability of the model given the data (note that in both of those examples those quantities would be maximized rather than minimized).\n\nTasks that fall within the paradigm of unsupervised learning are in general estimation problems; the applications include clustering, the estimation of statistical distributions, compression and filtering.\n\nReinforcement learning\nSee also: Stochastic control\nIn reinforcement learning, data {\\displaystyle \\textstyle x} \\textstyle x are usually not given, but generated by an agent\\'s interactions with the environment. At each point in time {\\displaystyle \\textstyle t} \\textstyle t, the agent performs an action {\\displaystyle \\textstyle y_{t}} \\textstyle y_{t} and the environment generates an observation {\\displaystyle \\textstyle x_{t}} \\textstyle x_{t} and an instantaneous cost {\\displaystyle \\textstyle c_{t}} \\textstyle c_{t}, according to some (usually unknown) dynamics. The aim is to discover a policy for selecting actions that minimizes some measure of a long-term cost, e.g., the expected cumulative cost. The environment\\'s dynamics and the long-term cost for each policy are usually unknown, but can be estimated.\n\nMore formally the environment is modeled as a Markov decision process (MDP) with states {\\displaystyle \\textstyle {s_{1},...,s_{n}}\\in S} \\textstyle {s_{1},...,s_{n}}\\in S and actions {\\displaystyle \\textstyle {a_{1},...,a_{m}}\\in A} \\textstyle {a_{1},...,a_{m}}\\in A with the following probability distributions: the instantaneous cost distribution {\\displaystyle \\textstyle P(c_{t}|s_{t})} \\textstyle P(c_{t}|s_{t}), the observation distribution {\\displaystyle \\textstyle P(x_{t}|s_{t})} \\textstyle P(x_{t}|s_{t}) and the transition {\\displaystyle \\textstyle P(s_{t+1}|s_{t},a_{t})} \\textstyle P(s_{t+1}|s_{t},a_{t}), while a policy is defined as the conditional distribution over actions given the observations. Taken together, the two then define a Markov chain (MC). The aim is to discover the policy (i.e., the MC) that minimizes the cost.\n\nArtificial neural networks are frequently used in reinforcement learning as part of the overall algorithm.[80][81] Dynamic programming was coupled with Artificial neural networks (giving neurodynamic programming) by Bertsekas and Tsitsiklis[82] and applied to multi-dimensional nonlinear problems such as those involved in vehicle routing,[83] natural resources management[84][85] or medicine[86] because of the ability of Artificial neural networks to mitigate losses of accuracy even when reducing the discretization grid density for numerically approximating the solution of the original control problems.\n\nTasks that fall within the paradigm of reinforcement learning are control problems, games and other sequential decision making tasks.\n\nLearning algorithms\nSee also: Machine learning\nTraining a neural network model essentially means selecting one model from the set of allowed models (or, in a Bayesian framework, determining a distribution over the set of allowed models) that minimizes the cost. Numerous algorithms are available for training neural network models; most of them can be viewed as a straightforward application of optimization theory and statistical estimation.\n\nMost employ some form of gradient descent, using backpropagation to compute the actual gradients. This is done by simply taking the derivative of the cost function with respect to the network parameters and then changing those parameters in a gradient-related direction. Backpropagation training algorithms fall into three categories:\n\nsteepest descent (with variable learning rate and momentum, resilient backpropagation);\nquasi-Newton (Broyden-Fletcher-Goldfarb-Shanno, one step secant);\nLevenberg-Marquardt and conjugate gradient (Fletcher-Reeves update, Polak-Ribi\u00e9re update, Powell-Beale restart, scaled conjugate gradient).[87]\nEvolutionary methods,[88] gene expression programming,[89] simulated annealing,[90] expectation-maximization, non-parametric methods and particle swarm optimization[91] are other methods for training neural networks.\n\nConvergent recursive learning algorithm\nThis is a learning method specially designed for cerebellar model articulation controller (CMAC) neural networks. In 2004, a recursive least squares algorithm was introduced to train CMAC neural network online.[92] This algorithm can converge in one step and update all weights in one step with any new input data. Initially, this algorithm had computational complexity of O(N3). Based on QR decomposition, this recursive learning algorithm was simplified to be O(N).[93]\n\n", "qas": [{"answers": [{"answer_start": -1, "text": ""}], "question": "Artificial neural network", "id": "Artificial neural network"}]}]}], "version": "my_ver"}